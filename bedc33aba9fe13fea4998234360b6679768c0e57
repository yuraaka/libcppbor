{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "4469d2a3_3389ddd2",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1043663
      },
      "writtenOn": "2021-04-01T14:16:59Z",
      "side": 1,
      "message": "Why not set the limit to vector\u003c\u003e::max_size()?",
      "revId": "bedc33aba9fe13fea4998234360b6679768c0e57",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4c372ed8_ea53c4e0",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1139038
      },
      "writtenOn": "2021-04-01T14:39:59Z",
      "side": 1,
      "message": "It\u0027s only vector\u003c\u003e::max_size() in certain cases but really depends on the ParserClient. In the case I saw failing, FullParserClient tried to make an instance of a Map subclass which happens to be implemented with std::vector. There\u0027re layers of abstraction in the API that hide what the right value is. This CL was mainly to point to where the problem was and see what you want the library\u0027s API to look like.",
      "parentUuid": "4469d2a3_3389ddd2",
      "revId": "bedc33aba9fe13fea4998234360b6679768c0e57",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8b0317f0_61b340a8",
        "filename": "src/cppbor_parse.cpp",
        "patchSetId": 2
      },
      "lineNbr": 104,
      "author": {
        "id": 1139038
      },
      "writtenOn": "2021-04-01T13:40:09Z",
      "side": 1,
      "message": "Seems it wants a check on `length` here so vector in the BStr doesn\u0027t throw a length_error too.",
      "range": {
        "startLine": 104,
        "startChar": 38,
        "endLine": 104,
        "endChar": 52
      },
      "revId": "bedc33aba9fe13fea4998234360b6679768c0e57",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "03754f12_efd975bc",
        "filename": "src/cppbor_parse.cpp",
        "patchSetId": 2
      },
      "lineNbr": 187,
      "author": {
        "id": 1139038
      },
      "writtenOn": "2021-03-30T16:49:14Z",
      "side": 1,
      "message": "This isn\u0027t the right way to do it but you might have an opinion on the way that would best fit the library.",
      "revId": "bedc33aba9fe13fea4998234360b6679768c0e57",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "cfd3be63_2999d4c7",
        "filename": "src/cppbor_parse.cpp",
        "patchSetId": 2
      },
      "lineNbr": 187,
      "author": {
        "id": 1043663
      },
      "writtenOn": "2021-04-01T19:42:54Z",
      "side": 1,
      "message": "What would best fit, I think, is to diagnose an error in ParseClient::item() and return a nullptr.  Maybe IncompleteItem::add() should return a bool to indicate success, so ParseClient::item() can see the failure and return nullptr.  Actually determining whether the vector\u003c\u003e::reserve succeeded may be problematic, but at least in Linux and Trusty I don\u0027t think there\u0027s anything we can usefully do in the event of out-of-memory other than crash.",
      "parentUuid": "03754f12_efd975bc",
      "revId": "bedc33aba9fe13fea4998234360b6679768c0e57",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4bda1957_6d27ec7b",
        "filename": "src/cppbor_parse.cpp",
        "patchSetId": 2
      },
      "lineNbr": 187,
      "author": {
        "id": 1139038
      },
      "writtenOn": "2021-04-06T10:35:54Z",
      "side": 1,
      "message": "Given the input CBOR might come from an untrusted source and it\u0027s a trivial condition to trigger, it seems like some attempt should be made to prevent a crash or at least define what a client should expect and how they might handle it themselves.\n\nWe\u0027ve touched on some of the extreme bounds that can be checked (vector::max_size). Maybe some clients want to restrict that further based on their environment or application, though that is more a feature than a fix.\n\nIf you have exceptions enabled, those generated by the STL related to allocation failures can either be handled or described as part of the API so the client can handle them. If exceptions are disabled (maybe trusty does so?) is the STL the right tool to be using since it will just abort rather than gracefully rejecting the input?",
      "parentUuid": "cfd3be63_2999d4c7",
      "revId": "bedc33aba9fe13fea4998234360b6679768c0e57",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    }
  ]
}